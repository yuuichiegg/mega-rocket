<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum=1.0, user-scalable=no, viewport-fit=cover">
    <title>Mega Rocket - V10.0 ULTIMATE - Integrated Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@500;700;900&display=swap');
        
        :root {
            --primary: #00aaff;
            --bg-overlay: rgba(10, 15, 25, 0.9);
            --warn: #ff3300;
            --caution: #ffcc00;
            --success: #00ff66;
            --ai-color: #d4a5ff;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
            --font-mono: 'Share Tech Mono', monospace;
            --font-ui: 'Rajdhani', sans-serif;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { margin: 0; padding: 0; background: #000; color: #fff; font-family: var(--font-mono); overflow: hidden; height: 100vh; width: 100vw; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; }

        /* Debug Console */
        #debug-console {
            position: absolute; top: 0; left: 0; width: 100%; height: auto; max-height: 50vh;
            background: rgba(50, 0, 0, 0.8); color: #ffcccc; font-size: 10px; padding: 5px;
            z-index: 10000; overflow-y: auto; display: none; pointer-events: none; white-space: pre-wrap;
        }

        .ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; cursor: pointer; }
        .interactive:active { transform: scale(0.96); opacity: 0.8; }

        /* PANELS */
        .panel {
            position: absolute; background: var(--bg-overlay);
            border: 1px solid rgba(0, 170, 255, 0.3); border-radius: 4px; padding: 8px;
            backdrop-filter: blur(8px); pointer-events: none; box-shadow: 0 4px 15px rgba(0,0,0,0.6);
        }

        #hud-left { top: calc(var(--safe-top) + 10px); left: 10px; width: 150px; border-left: 3px solid var(--primary); transform-origin: top left; }
        .stat-row { display: flex; justify-content: space-between; align-items: baseline; font-size: 11px; color: #8899aa; margin-bottom: 2px; }
        .stat-val { font-family: var(--font-ui); font-weight: 700; color: #fff; font-size: 18px; letter-spacing: 1px; text-shadow: 0 0 5px rgba(0,170,255,0.5); }
        
        #timer {
            font-size: 24px; color: #ffcc00; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 5px; padding-bottom: 2px; font-variant-numeric: tabular-nums;
            text-shadow: 0 0 8px rgba(255, 204, 0, 0.4);
        }

        /* SETTINGS */
        #settings-panel { top: calc(var(--safe-top) + 60px); right: 10px; width: 170px; display: none; z-index: 100; pointer-events: auto; border-right: 3px solid #fff; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; font-size: 11px; color: #ccc; }
        .toggle-switch { width: 34px; height: 18px; background: #444; border-radius: 9px; position: relative; transition: 0.3s; cursor: pointer; border: 1px solid #666; }
        .toggle-knob { width: 14px; height: 14px; background: #fff; border-radius: 50%; position: absolute; top: 1px; left: 2px; transition: 0.3s; }
        .toggle-switch.on { background: var(--success); border-color: var(--success); }
        .toggle-switch.on .toggle-knob { transform: translateX(16px); }

        /* REPORT PANEL */
        #report-panel {
            top: 50%; left: 50%; transform: translate(-50%, -50%); width: 320px; height: auto; max-height: 80vh;
            background: rgba(10, 20, 30, 0.95); border: 2px solid var(--primary); z-index: 200; display: none;
            pointer-events: auto; flex-direction: column; gap: 10px; box-shadow: 0 0 30px rgba(0,170,255,0.2);
        }
        #report-title { font-family: var(--font-ui); font-size: 22px; color: var(--primary); text-align: center; border-bottom: 1px solid #333; padding-bottom: 5px; letter-spacing: 2px; }
        #report-content { font-size: 13px; color: #ddd; line-height: 1.6; }
        #report-ai { margin-top: 10px; padding: 10px; background: rgba(212, 165, 255, 0.08); border-left: 3px solid var(--ai-color); font-style: italic; color: #eebbff; font-size: 12px; min-height: 40px; }
        .close-btn { align-self: center; margin-top: 10px; padding: 8px 30px; border: 1px solid #555; background: linear-gradient(to bottom, #333, #222); color: #fff; cursor: pointer; font-family: var(--font-ui); font-weight: bold; letter-spacing: 1px; }
        .close-btn:hover { border-color: #fff; background: #444; }

        /* WEATHER & MINIMAP */
        #weather { top: calc(var(--safe-top) + 10px); right: 10px; text-align: right; border-right: 3px solid var(--success); width: auto; min-width: 130px; transform-origin: top right; }
        #real-time { font-size: 18px; font-weight: 700; font-family: var(--font-ui); }
        #weather-info { font-size: 10px; color: #ccc; text-transform: uppercase; letter-spacing: 1px; }
        #minimap-container { top: calc(var(--safe-top) + 80px); right: 10px; width: 140px; height: 140px; padding: 0; overflow: hidden; transition: transform 0.3s; border-radius: 50%; border: 2px solid rgba(0, 170, 255, 0.5); background: #001122; }
        #minimap-container.closed { transform: scale(0); opacity: 0; }
        #minimap-canvas { width: 100%; height: 100%; }

        /* CONTROLS */
        #controls-area {
            position: absolute; bottom: 0; left: 0; width: 100%;
            display: flex; justify-content: space-between; align-items: flex-end; padding: 20px;
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 100%);
            pointer-events: none; transition: all 0.3s;
        }
        #joystick-zone { width: 130px; height: 130px; background: rgba(255,255,255,0.05); border: 1px dashed rgba(255,255,255,0.2); border-radius: 50%; position: relative; pointer-events: auto; touch-action: none; }
        #stick-handle { width: 50px; height: 50px; background: radial-gradient(circle at 30% 30%, #445566, #112233); border: 1px solid var(--primary); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        #throttle-zone { width: 60px; height: 200px; background: rgba(10,20,30,0.8); border: 1px solid #445566; border-radius: 8px; position: relative; overflow: hidden; pointer-events: auto; touch-action: none; }
        #throttle-fill { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: linear-gradient(to top, var(--warn), #ffcc00); opacity: 0.8; transition: height 0.05s linear; }
        #throttle-knob { position: absolute; left: 0; bottom: 0%; width: 100%; height: 30px; background: rgba(255,255,255,0.9); border-top: 2px solid #fff; border-bottom: 2px solid #ccc; transform: translateY(50%); pointer-events: none; box-shadow: 0 -2px 5px rgba(0,0,0,0.3); transition: bottom 0.05s linear; }
        .th-mark { position: absolute; left: 0; width: 100%; height: 1px; background: rgba(255,255,255,0.2); pointer-events: none; }

        #btn-group { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px; pointer-events: auto; width: 100%; max-width: 420px; margin-left: 20px; }
        .btn { width: 100%; height: 55px; background: rgba(30,40,50,0.8); border: 1px solid #556677; border-radius: 8px; color: #fff; font-size: 10px; font-weight: bold; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: all 0.1s; letter-spacing: 1px; }
        .btn i { font-style: normal; font-size: 16px; margin-bottom: 2px; }
        .btn.active { border-color: var(--primary); background: rgba(0,170,255,0.25); color: var(--primary); box-shadow: 0 0 10px rgba(0,170,255,0.2); }
        .btn.disabled { opacity: 0.3; pointer-events: none; filter: grayscale(1); }
        .btn-ai { border-color: var(--ai-color); color: var(--ai-color); }
        .btn-ai.active, .btn-ai:active { background: rgba(212, 165, 255, 0.2); }
        .btn-bft { border-color: #ff9900; color: #ff9900; }
        .btn-bft:active { background: rgba(255, 153, 0, 0.3); transform: scale(0.95); }

        #top-btns { position: absolute; top: calc(var(--safe-top) + 10px); left: 170px; display: flex; gap: 8px; pointer-events: auto; }
        .mini-btn { width: 36px; height: 36px; background: rgba(0,0,0,0.6); border: 1px solid #445566; border-radius: 4px; color: #fff; display: flex; justify-content: center; align-items: center; font-size: 16px; transition: background 0.2s; }
        .mini-btn:hover { background: rgba(255,255,255,0.1); border-color: #fff; }

        #auto-selector {
            position: absolute; bottom: 250px; left: 50%; transform: translateX(-50%) scale(0);
            width: 220px; background: rgba(0, 20, 40, 0.95); border: 1px solid var(--primary); border-radius: 8px;
            padding: 12px; display: flex; flex-direction: column; gap: 8px; z-index: 100;
            transition: transform 0.2s; pointer-events: auto; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #auto-selector.active { transform: translateX(-50%) scale(1); }
        .selector-btn {
            background: rgba(0, 100, 200, 0.2); border: 1px solid var(--primary); color: #fff;
            padding: 12px; border-radius: 4px; cursor: pointer; text-align: center;
            font-weight: bold; font-family: var(--font-ui); font-size: 14px; letter-spacing: 1px; transition: background 0.2s;
        }
        .selector-btn:active { background: var(--primary); color: #000; }

        #center-msg {
            position: absolute; top: 30%; width: 100%; text-align: center; font-size: 36px;
            font-weight: 900; color: var(--primary); text-shadow: 0 0 20px var(--primary);
            pointer-events: none; opacity: 0; transition: opacity 0.2s; font-family: var(--font-ui);
            z-index: 20; letter-spacing: 2px;
        }
        #fail-reason { font-size: 16px; color: #ffcccc; margin-top: 5px; font-weight: 500; text-shadow: none; letter-spacing: 0; }
        #ai-subtitle {
            position: absolute; top: 18%; width: 80%; left: 10%; text-align: center;
            color: var(--ai-color); font-family: var(--font-ui); font-weight: 700;
            text-shadow: 0 0 10px rgba(0,0,0,0.8); font-size: 18px; pointer-events: none;
            opacity: 0; transition: opacity 0.5s; background: rgba(0,0,0,0.7);
            padding: 10px; border-radius: 8px; border: 1px solid var(--ai-color); z-index: 15;
        }
        #countdown {
            position: absolute; top: 35%; width: 100%; text-align: center; font-size: 120px;
            font-weight: 900; color: #fff; text-shadow: 0 0 30px var(--warn);
            pointer-events: none; font-family: var(--font-ui); opacity: 0; transition: opacity 0.2s; z-index: 20;
        }
        #vessel-tag {
            position: absolute; bottom: 220px; left: 20px; background: rgba(0,0,0,0.7); padding: 4px 10px;
            border: 1px solid var(--primary); border-radius: 12px; font-size: 10px; color: var(--primary);
            pointer-events: auto; font-weight: bold; border: 1px solid var(--primary); box-shadow: 0 0 10px rgba(0,170,255,0.3);
        }
        #auto-tag { position: absolute; bottom: 200px; left: 20px; font-size: 10px; color: var(--success); text-shadow: 0 0 5px #000; opacity: 0; transition: opacity 0.3s; font-weight: bold; }
        #phase-tag { position: absolute; bottom: 185px; left: 20px; font-size: 10px; color: #aabbcc; opacity: 0; transition: opacity 0.3s; text-transform: uppercase; letter-spacing: 1px; font-weight: bold; }

        /* „Çπ„Çø„Éº„ÉàÁîªÈù¢ */
        #start-screen {
            position: absolute; inset: 0; background: #000; z-index: 9999; display: flex; flex-direction: column;
            justify-content: center; align-items: center; transition: opacity 0.5s; pointer-events: auto;
            cursor: pointer; background-image: radial-gradient(circle at 50% 50%, #112233 0%, #000 70%);
        }
        #start-screen:active { background-image: radial-gradient(circle at 50% 50%, #223344 0%, #000 70%); }
        #start-screen.fade-out { opacity: 0; pointer-events: none; }
        .title-text {
            font-family: var(--font-ui); font-size: 52px; color: #fff; text-shadow: 0 0 30px var(--primary);
            margin-bottom: 5px; font-weight: 900; letter-spacing: -2px; text-align: center; line-height: 1;
        }
        .subtitle-text { color:#8899aa; margin-bottom:50px; font-size:16px; font-family: var(--font-mono); letter-spacing: 4px; text-transform: uppercase; }
        .big-btn {
            padding: 18px 60px; font-size: 22px; font-weight: 800; background: var(--primary);
            border: none; border-radius: 2px; color: #000; box-shadow: 0 0 20px var(--primary);
            cursor: pointer; font-family: var(--font-ui); letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%); transition: all 0.1s; pointer-events: none;
        }
        #start-screen:active .big-btn { transform: scale(0.96); background: #fff; box-shadow: 0 0 40px #fff; }

        #replay-indicator {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: #cc0000; color: #fff; padding: 5px 20px; border-radius: 4px;
            font-weight: bold; font-family: var(--font-ui); z-index: 50; display: none;
            animation: pulse 1s infinite; font-size: 14px; letter-spacing: 1px; box-shadow: 0 0 10px #f00;
        }
        @keyframes pulse { 0% { opacity: 0.8; } 50% { opacity: 1; transform: translateX(-50%) scale(1.05); } 100% { opacity: 0.8; } }

        @media (orientation: landscape) {
            #controls-area { padding: 10px 40px; height: 160px; }
            #joystick-zone { width: 140px; height: 140px; }
            #throttle-zone { width: 50px; height: 150px; }
            .btn { width: auto; min-width: 65px; height: 50px; font-size: 10px; }
            #btn-group { grid-template-columns: repeat(4, 1fr); max-width: 450px; }
        }
        @media (max-width: 768px) {
            #controls-area { height: 240px; padding-bottom: calc(var(--safe-bottom) + 15px); }
            #joystick-zone { width: 120px; height: 120px; }
            .btn { height: 50px; font-size: 9px; }
            #btn-group { grid-template-columns: repeat(4, 1fr); margin-left: 10px; gap: 6px; width: auto; }
            #hud-left, #weather { transform: scale(0.9); }
            .title-text { font-size: 42px; }
        }
    </style>
    <script>
        window.onerror = function(msg, url, line) {
            const el = document.getElementById('debug-console');
            if(el) {
                el.style.display = 'block';
                el.innerText += "Err: " + msg + " (L" + line + ")\n";
            }
            return false;
        };
    </script>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    <div id="debug-console"></div>
    <div id="replay-indicator">‚è™ REPLAY MODE</div>
    
    <div class="ui-layer">
        <div id="hud-left" class="panel">
            <div id="timer">T- 10.0</div>
            <div class="stat-row">ALTITUDE <span class="stat-val"><span id="val-alt">0</span>m</span></div>
            <div class="stat-row">VELOCITY <span class="stat-val"><span id="val-spd">0</span>m/s</span></div>
            <div class="stat-row">FUEL <span class="stat-val"><span id="val-fuel">100</span>%</span></div>
        </div>

        <div id="weather" class="panel">
            <div id="real-time">--:--</div>
            <div id="weather-info">LINKING...</div>
        </div>

        <div id="minimap-container" class="panel">
            <canvas id="minimap-canvas"></canvas>
        </div>

        <div id="top-btns">
            <button class="mini-btn interactive" id="btn-settings">‚öôÔ∏è</button>
            <button class="mini-btn interactive" id="btn-map">üó∫Ô∏è</button>
            <button class="mini-btn interactive" id="btn-audio">üîá</button>
        </div>

        <div id="settings-panel" class="panel">
            <div class="setting-row">
                <span>TRAJECTORY</span>
                <div class="toggle-switch on" id="opt-traj"><div class="toggle-knob"></div></div>
            </div>
            <div class="setting-row">
                <span>MASS PHYSICS</span>
                <div class="toggle-switch on" id="opt-mass"><div class="toggle-knob"></div></div>
            </div>
            <div class="setting-row">
                <span>AUTO REPLAY</span>
                <div class="toggle-switch" id="opt-replay"><div class="toggle-knob"></div></div>
            </div>
        </div>

        <!-- Report Modal -->
        <div id="report-panel" class="panel">
            <div id="report-title">MISSION STATUS</div>
            <div id="report-content">Loading data...</div>
            <div id="report-ai">Analyzing telemetry...</div>
            <div class="close-btn interactive" onclick="document.getElementById('report-panel').style.display='none'">CLOSE</div>
        </div>

        <div id="center-msg"></div>
        <div id="ai-subtitle"></div>
        <div id="countdown"></div>
        <div id="vessel-tag" class="interactive">BOOSTER</div>
        <div id="auto-tag">AUTO</div>
        <div id="phase-tag">PHASE: HOLD</div>

        <div id="auto-selector" class="panel">
            <div style="text-align:center; color:#aaa; font-size:10px; margin-bottom:5px; letter-spacing:1px;">FLIGHT COMPUTER</div>
            <div class="selector-btn" id="mode-land">üéØ AUTO LAND</div>
            <div class="selector-btn" id="mode-hover">‚öì STABILIZE</div>
            <div class="selector-btn" id="mode-off" style="border-color:#555; opacity:0.7">‚ùå MANUAL</div>
        </div>

        <div id="controls-area">
            <div id="joystick-zone">
                <div id="stick-handle"></div>
            </div>
            <div id="btn-group">
                <button class="btn interactive" id="btn-cam"><i>üîÑ</i>CAM</button>
                <button class="btn interactive" id="btn-gear"><i>‚öôÔ∏è</i>GEAR</button>
                <button class="btn interactive" id="btn-sas"><i>‚öì</i>SAS</button>
                <button class="btn interactive disabled" id="btn-auto"><i>ü§ñ</i>AUTO</button>
                <button class="btn interactive" id="btn-sep"><i>üöÄ</i>SEP</button>
                <button class="btn interactive" id="btn-rst"><i>‚Üª</i>RST</button>
                <button class="btn interactive btn-bft" id="btn-bft"><i>üî•</i>BFT</button>
                <button class="btn interactive btn-ai" id="btn-ai-status"><i>üìä</i>REPORT</button>
            </div>
            <div id="throttle-zone">
                <div class="th-mark" style="bottom:25%"></div>
                <div class="th-mark" style="bottom:50%"></div>
                <div class="th-mark" style="bottom:75%"></div>
                <div id="throttle-fill"></div>
                <div id="throttle-knob"></div>
            </div>
        </div>
    </div>

    <div id="start-screen">
        <div class="title-text">MEGA ROCKET</div>
        <div class="subtitle-text">V10.0 ULTIMATE - Integrated Edition</div>
        <div style="font-size:12px; color:#666; margin-bottom:10px;">TAP SCREEN TO LAUNCH</div>
        <button class="big-btn" id="btn-launch">INITIATE LAUNCH</button>
    </div>

<script>
// --- CONSTANTS & TUNING ---
// REFACTOR: V9.8 Tunings
const CONFIG = {
    G: 9.81,
    PAD_Y: 0,
    MECHAZILLA: { Y: -120, X: -40, W: 30, TOWER_W: 30, ARM_W: 60, ARM_H: 14 },
    SHIP_PAD: { X: 250, Y: 0, W: 60 },
    BOOSTER: { THRUST: 140000, MASS: 600, FUEL: 2000, H: 120, W: 20, DRAG: 0.8 },
    SHIP: { THRUST: 50000, MASS: 250, FUEL: 800, H: 70, W: 20, DRAG: 2.5 },
    ATMOSPHERE: { DENSITY: 1.5, HEIGHT: 40000 },
    CAM: { ZOOM_MIN: 0.05, ZOOM_MAX: 4.0 },
    DT_FIXED: 1/60,
    CATCH_PHYSICS: {
        // Tuned for "Soft & Damped" Catch (V9.6)
        STIFFNESS_Y: 120.0,  // Softer spring
        DAMPING_Y: 26.0,     // Higher damping
        STIFFNESS_X: 95.0,
        DAMPING_X: 22.0,
        FRICTION_GRIP: 9.0,  // High friction
        ANGULAR_CORRECTION: 90.0 // Strong upright correction
    },
    AUTO_LAND: {
        ALIGNMENT_ALT: 1000,
        BOOSTER_STEER_GAIN: 0.018, // 0.008 -> 0.018 („É¶„Éº„Ç∂„ÉºÊåáÂÆö)
        SHIP_STEER_GAIN: 0.005 
    }
};

const CONSTANTS = {
    VESSEL: { BOOSTER: 'booster', SHIP: 'ship' },
    STATE: { MENU: 'MENU', COUNTDOWN: 'COUNTDOWN', FLIGHT: 'FLIGHT', REPLAY: 'REPLAY' },
    AUTO: { OFF: 'OFF', LAND: 'LAND', HOVER: 'HOVER', ORBIT: 'ORBIT', COAST: 'COAST' },
    COLORS: { PRIMARY: '#00aaff', SUCCESS: '#00ff66', WARN: '#ff3300', CAUTION: '#ffcc00' }
};

const Utils = {
    clamp: (v, m, M) => Math.max(m, Math.min(M, v)),
    lerp: (a, b, t) => a + (b - a) * t,
    dist: (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2),
    rand: (min, max) => Math.random() * (max - min) + min,
    normalizeAngle: (a) => {
        while (a > Math.PI) a -= 2 * Math.PI;
        while (a < -Math.PI) a += 2 * Math.PI;
        return a;
    }
};

// --- GEMINI AI INTEGRATION ---
class GeminiBridge {
    constructor() {
        this.apiKey = ""; // Provided by environment
        this.modelText = "gemini-2.5-flash-preview-09-2025";
        this.modelTTS = "gemini-2.5-flash-preview-tts";
        this.isProcessing = false;
    }

    async generateCommentary(context, isReport = false) {
        if (this.isProcessing) return;
        this.isProcessing = true;
        
        const btn = document.getElementById('btn-ai-status');
        if(btn) btn.style.opacity = 0.5;

        const reportEl = document.getElementById('report-ai');
        if(isReport && reportEl) reportEl.innerText = "Connecting to Mission Control...";

        const sysPrompt = isReport 
            ? `You are a flight director. Provide a short, professional mission status report in Japanese based on telemetry. Keep it under 40 words.` 
            : `You are a flight director. Provide a concise status update in Japanese. Keep it under 20 words. Tone: Professional.`;
        
        const userPrompt = `Telemetry: ${context}`;

        try {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.modelText}:generateContent?key=${this.apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: userPrompt }] }],
                systemInstruction: { parts: [{ text: sysPrompt }] }
            };

            const response = await this.fetchWithBackoff(url, payload);
            const data = await response.json();
            const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "Communication Error";
            
            if (isReport && reportEl) {
                reportEl.innerText = "MISSION CONTROL: " + text;
            } else {
                this.displaySubtitle(text);
                await this.speak(text);
            }
        } catch (e) {
            console.error("Gemini Error:", e);
            if(isReport && reportEl) reportEl.innerText = "CONN LOSS - AI OFFLINE";
            else this.displaySubtitle("CONN LOSS - RETRYING...");
        } finally {
            this.isProcessing = false;
            if(btn) btn.style.opacity = 1;
        }
    }

    async speak(text) {
        try {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.modelTTS}:generateContent?key=${this.apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } }
                }
            };

            const response = await this.fetchWithBackoff(url, payload);
            const data = await response.json();
            const audioData = data.candidates[0].content.parts[0].inlineData.data;
            this.playAudio(audioData);
        } catch (e) { console.error("TTS Error:", e); }
    }

    playAudio(base64Data) {
        try {
            const binaryString = window.atob(base64Data);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binaryString.charCodeAt(i);

            const audioCtx = window.game.audio.ctx || new (window.AudioContext || window.webkitAudioContext)();
            const wavBuffer = this.pcmToWav(bytes, 24000);

            audioCtx.decodeAudioData(wavBuffer.buffer, (buffer) => {
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start(0);
            });
        } catch(e) { console.error("Audio Decode Error", e); }
    }

    pcmToWav(pcmData, sampleRate) {
        const numChannels = 1;
        const bitsPerSample = 16;
        const byteRate = sampleRate * numChannels * bitsPerSample / 8;
        const blockAlign = numChannels * bitsPerSample / 8;
        const wavHeader = new ArrayBuffer(44 + pcmData.length);
        const view = new DataView(wavHeader);

        const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
        };

        writeString(0, 'RIFF');
        view.setUint32(4, 36 + pcmData.length, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, byteRate, true);
        view.setUint16(32, blockAlign, true);
        view.setUint16(34, bitsPerSample, true);
        writeString(36, 'data');
        view.setUint32(40, pcmData.length, true);

        const pcmView = new Uint8Array(wavHeader, 44);
        pcmView.set(pcmData);
        return new Uint8Array(wavHeader);
    }

    async fetchWithBackoff(url, payload, retries = 3) {
        let delay = 1000;
        for (let i = 0; i < retries; i++) {
            try {
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (res.ok) return res;
            } catch (e) {}
            await new Promise(r => setTimeout(r, delay));
            delay *= 2;
        }
        throw new Error("API Failed");
    }

    displaySubtitle(text) {
        const el = document.getElementById('ai-subtitle');
        if (el) {
            el.innerText = "MISSION CONTROL: " + text;
            el.style.opacity = 1;
            setTimeout(() => { el.style.opacity = 0; }, 5000);
        }
    }
}

// --- MANAGERS ---
class SettingsManager {
    constructor() {
        const defaults = { trajectory: true, massShift: true, replay: false };
        this.config = defaults;
        this.STORAGE_KEY = 'rocket-config-v17';
        this.load();
    }
    load() {
        try {
            const saved = localStorage.getItem(this.STORAGE_KEY);
            if (saved) {
                const loaded = JSON.parse(saved);
                if (Object.prototype.hasOwnProperty.call(loaded, 'replay')) delete loaded.replay;
                this.config = { ...this.config, ...loaded };
            }
        } catch(e) {}
    }
    save() {
        try { localStorage.setItem(this.STORAGE_KEY, JSON.stringify(this.config)); } catch(e) {}
    }
    toggle(key, el) {
        this.config[key] = !this.config[key];
        if(el) el.classList.toggle('on', this.config[key]);
        this.save();
    }
    applyToDOM() {
        try {
            const bind = (id, k) => {
                const el = document.getElementById(id);
                if(el) el.classList.toggle('on', this.config[k]);
            };
            bind('opt-traj', 'trajectory');
            bind('opt-mass', 'massShift');
            bind('opt-replay', 'replay');
        } catch(e) {}
    }
}

class ParticleSystem {
    constructor(maxParticles = 2000) {
        this.particles = [];
        this.pool = [];
        this.maxParticles = maxParticles;
    }
    add(x, y, vx, vy, s, type, life = 1.0) {
        let p = this.pool.pop() || {};
        p.x = x; p.y = y; p.vx = vx; p.vy = vy; p.s = s; p.c = type;
        p.life = life; p.maxLife = life; p.active = true;
        this.particles.push(p);
        if (this.particles.length > this.maxParticles) this.recycle(this.particles.shift());
    }
    update(dt) {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.life -= dt; p.x += p.vx * dt; p.y += p.vy * dt;
            if (p.c !== 'shock') p.s *= 0.96;
            if (p.life <= 0) {
                p.active = false;
                this.recycle(this.particles.splice(i, 1)[0]);
            }
        }
    }
    recycle(p) { this.pool.push(p); }
    clear() { while(this.particles.length > 0) this.recycle(this.particles.pop()); }
}

class PhysicsEngine {
    constructor(game) { this.game = game; }
    
    update(v, dt) {
        if (v.caught) return this.updateCaught(v, dt);
        
        if (!v.landed && v.active && !v.crashed) {
            this.updateFlight(v, dt);
            const safeLaunch = (!v.hasLiftedOff);
            if (!safeLaunch && v.y + v.h/2 >= CONFIG.PAD_Y - (v.gear * v.gearOffset)) this.game.handleLanding(v, 'LANDED');
            if (!v.hasLiftedOff && v.y < CONFIG.PAD_Y - v.h/2 - 30) v.hasLiftedOff = true;
        }
    }

    updateCaught(v, dt) {
        v.th = 0; v.thTgt = 0; v.auto = false;
        
        const armPadY = CONFIG.MECHAZILLA.Y;
        const h = v.h || 120;
        const rocketPinY = v.y - (h * 0.38);
        
        v.vy += CONFIG.G * dt; // Gravity

        // Vertical Spring-Damper
        if (rocketPinY > armPadY) {
            const penetration = rocketPinY - armPadY;
            const kY = CONFIG.CATCH_PHYSICS.STIFFNESS_Y;
            const dY = CONFIG.CATCH_PHYSICS.DAMPING_Y;
            const forceY = -penetration * kY - v.vy * dY;
            v.vy += forceY * dt;
            // V9.6 Soft Bounce Fix: Reduced repulsion factor from 0.1 to 0.06
            if (penetration > 2.0) v.y -= (penetration - 2.0) * 0.06;
        }

        // Horizontal Squeeze
        const towerCx = CONFIG.MECHAZILLA.X;
        const armOpen = this.game.mechazilla?.armOpen ?? 1.0;
        const w = v.w || 20;
        const rocketHalfW = w / 2;
        const armGap = rocketHalfW + (armOpen * 35);
        
        const leftPadX = towerCx - armGap;
        const rightPadX = towerCx + armGap;
        const rocketLeft = v.x - rocketHalfW;
        const rocketRight = v.x + rocketHalfW;

        const kX = CONFIG.CATCH_PHYSICS.STIFFNESS_X;
        const dX = CONFIG.CATCH_PHYSICS.DAMPING_X;

        // Collision Check
        if (rocketLeft < leftPadX) {
            const pen = leftPadX - rocketLeft;
            v.vx += (pen * kX - v.vx * dX) * dt;
            v.x += pen * 0.1;
        }
        if (rocketRight > rightPadX) {
            const pen = rocketRight - rightPadX;
            v.vx -= (pen * kX + v.vx * dX) * dt;
            v.x -= pen * 0.1;
        }

        // Friction & Angular Stabilizer
        const gripFactor = 1.0 - armOpen;
        if (gripFactor > 0.1) {
            const fGrip = CONFIG.CATCH_PHYSICS.FRICTION_GRIP;
            v.vx *= (1.0 - fGrip * gripFactor * dt);
            v.vy *= (1.0 - 2.0 * gripFactor * dt);
            v.angVel *= (1.0 - 10.0 * gripFactor * dt);
            const angForce = -v.ang * CONFIG.CATCH_PHYSICS.ANGULAR_CORRECTION * gripFactor;
            v.angVel += angForce * dt;
        }

        // --- Soft Capture Snap (V9.6) ---
        // Pulls vessel to exact center when arms are mostly closed
        const tx = CONFIG.MECHAZILLA.X;
        const ty = CONFIG.MECHAZILLA.Y;
        const pinY_current = v.y - (h * 0.38);
        const dy = pinY_current - ty; // Distance from ideal catch height
        const grip = Utils.clamp(1.0 - (this.game.mechazilla?.armOpen ?? 1.0), 0, 1);

        if (grip > 0.65) {
            // Gently lerp position to center (Magnetic snap effect)
            v.x = Utils.lerp(v.x, tx, 0.10);
            v.y = Utils.lerp(v.y, v.y - dy, 0.10);

            // Aggressively kill residual velocity
            v.vx *= (1.0 - 6.0 * dt);
            v.vy *= (1.0 - 8.0 * dt);

            // Force upright
            v.ang = Utils.lerp(v.ang, 0.0, 0.10);
            v.angVel *= (1.0 - 10.0 * dt);

            // Eliminate micro-jitter
            if (Math.abs(v.vx) < 0.15) v.vx = 0;
            if (Math.abs(v.vy) < 0.15) v.vy = 0;
            if (Math.abs(v.angVel) < 0.02) v.angVel = 0;

            // --- HARD LOCK (V9.8) ---
            if (!v.captured) {
                const centerOK = Math.abs(v.x - tx) < 0.6;
                const heightOK = Math.abs(dy) < 0.6;
                const velOK = Math.abs(v.vx) < 0.25 && Math.abs(v.vy) < 0.35;
                const angOK = Math.abs(v.ang) < 0.03 && Math.abs(v.angVel) < 0.05;

                if (grip > 0.88 && centerOK && heightOK && velOK && angOK) {
                    v.captured = true;
                }
            }
        }

        if (v.captured) {
            v.x = tx;
            v.y = v.y - dy; // Match pin height exactly
            v.vx = 0; v.vy = 0;
            v.ang = 0; v.angVel = 0;
            return; // Stop integration
        }

        this.integrate(v, dt);
    }

    updateFlight(v, dt) {
        if (v.fuel <= 0) { v.fuel = 0; v.thTgt = 0; }
        
        if (this.game.settings.config.replay && this.game.time % 0.05 < dt) this.game.recordHistory(v);
        
        if (v.id === this.game.focus) {
            if (v.auto) this.game.autopilot.run(v, dt);
            else this.applyInput(v, dt);
        } else if (v.auto) {
            this.game.autopilot.run(v, dt);
        }

        if (!v.hasLiftedOff && v.type === CONSTANTS.VESSEL.BOOSTER && this.game.state === CONSTANTS.STATE.FLIGHT) {
            v.thTgt = 1.0; v.th = 1.0;
        } else {
            const lerpFactor = v.auto ? 0.08 : 0.1;
            v.th = Utils.lerp(v.th, v.fuel > 0 ? v.thTgt : 0, lerpFactor);
        }

        v.gear = Utils.lerp(v.gear, v.gearTgt ? 1 : 0, 0.05);
        v.vy += CONFIG.G * dt;

        if (v.th > 0.001) {
            const mass = v.mass + (v.fuel / 100) * v.mass;
            const f = v.thrust * v.th;
            v.vx += (Math.sin(v.ang) * f / mass) * dt;
            v.vy -= (Math.cos(v.ang) * f / mass) * dt;
            v.fuel -= v.th * 0.5 * dt;

            const count = Math.ceil(v.th * 6);
            for(let i = 0; i < count; i++) {
                const speed = 120 + Math.random() * 60;
                const spread = (Math.random() - 0.5) * 20;
                const evx = -Math.sin(v.ang) * speed + spread;
                const evy = Math.cos(v.ang) * speed;
                const exX = v.x - Math.sin(v.ang) * (v.h/2 + 3);
                const exY = v.y + Math.cos(v.ang) * (v.h/2 + 3);
                const pType = Math.random() < 0.2 ? 'smoke' : 'fire';
                const pSize = Utils.rand(5, 12);
                const life = 0.3 + Math.random() * 0.3;
                this.game.particles.add(exX, exY, v.vx + evx, v.vy + evy, pSize, pType, life);
            }
        }

        this.applyAerodynamics(v, dt);
        this.integrate(v, dt);

        if (this.game.time % 0.1 < dt) {
            v.trail.push({x: v.x, y: v.y});
            if (v.trail.length > 50) v.trail.shift();
        }

        if (v.type === CONSTANTS.VESSEL.BOOSTER && v.hasLiftedOff) {
            const pinY = v.y - (v.h * 0.38);
            const towerY = CONFIG.MECHAZILLA.Y;
            if (Math.abs(pinY - towerY) < 18) {
                // V9.8: Tightened catch condition
                if (Math.abs(v.x - CONFIG.MECHAZILLA.X) < 14) {
                    if (Math.abs(v.vy) < 25 && Math.abs(v.vx) < 12.0 && Math.abs(v.ang) < 0.25) {
                        this.game.handleLanding(v, 'MECHAZILLA CATCH');
                    }
                }
            }
        }
    }

    applyInput(v, dt) {
        if (v.fuel > 0 && v.hasLiftedOff) v.thTgt = this.game.input.th;
        let turn = this.game.input.x * 1.5;
        if (this.game.settings.config.massShift) turn *= (1.5 - (0.4 + (v.fuel/v.fuelMax)*0.6) * 0.5);
        v.angVel += turn * dt;
        if (this.game.sas && Math.abs(this.game.input.x) < 0.05) {
            v.angVel -= v.angVel * 2.0 * dt;
        }
    }

    applyAerodynamics(v, dt) {
        const alt = -v.y;
        const den = Math.max(0, 1 - alt/CONFIG.ATMOSPHERE.HEIGHT);
        if (den <= 0) return;

        let baseWind = (this.game.weather.wind / 3.6) || 0;
        if (alt > 5000 && alt < 15000) baseWind += 20;
        
        // 3) „Ç¨„Çπ„ÉàÊäëÂà∂ (AUTO‰∏≠„ÅØÂº±„ÇÅ„Çã)
        const gustScale = (v.auto ? 0.12 : 0.5); 
        const gust = (Math.random() - 0.5) * baseWind * gustScale;
        const windX = baseWind + gust;
        
        const rVx = v.vx - windX;
        const rVy = v.vy;
        const spd = Math.sqrt(rVx*rVx + rVy*rVy);
        if (spd < 0.1) return;

        const ux = Math.sin(v.ang);
        const uy = -Math.cos(v.ang);
        const uvx = rVx / spd;
        const uvy = rVy / spd;
        const dot = ux * uvx + uy * uvy;
        const absDot = Math.abs(dot);

        // 1) Á©∫Âäõ‰øÇÊï∞„ÅÆÂº∑Âåñ (10~50ÂÄç)
        // PhysicsEngine.applyAerodynamics() „ÅÆ‰øÇÊï∞„ÅåÂ∞è„Åï„Åô„Åé„Åæ„Åô„ÄÇ„Åì„Åì„ÇíÁΩÆÊèõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ
        const baseCd  = (v.type === 'ship') ? 0.0012 : 0.0010;   // 10x
        const bellyCd = (v.type === 'ship') ? 0.018  : 0.028;    // 10„Äú15x

        const currentCd = Utils.lerp(bellyCd, baseCd, absDot);

        const dragForce = 0.5 * den * (spd * spd) * currentCd * (v.w * v.h);
        v.vx -= (uvx * dragForce / v.mass) * dt;
        v.vy -= (uvy * dragForce / v.mass) * dt;

        // LiftÔºàÊ®™„Å∏Êªë„ÇãÂäõÔºâ„ÇÇÂ§ß„Åç„Åè„Åô„Çã
        if (spd > 12) {
            const liftCoeff = (v.type === 'ship') ? 1.2 : 2.2; // BOOSTER„ÇíÂº∑„Åè
            const liftMag = dragForce * liftCoeff * Math.sin(v.ang * 2);

            const liftX = -uvy * liftMag;
            const liftY =  uvx * liftMag;

            v.vx += (liftX / v.mass) * dt;
            v.vy += (liftY / v.mass) * dt;
        }

        v.angVel *= (1.0 - (den * spd * 0.0001));
    }

    integrate(v, dt) {
        v.ang += v.angVel * dt;
        v.ang = Utils.normalizeAngle(v.ang);
        v.x += v.vx * dt;
        v.y += v.vy * dt;
    }
}

class Autopilot {
    run(v, dt) {
        if (v.fuel <= 0) { v.thTgt = 0; v.auto = false; return; }
        // V9.5 FIX: Correct Target Coordinates
        // Mechazilla X is -40, Ship Pad X is 250.
        const targetX = (v.type === CONSTANTS.VESSEL.BOOSTER ? CONFIG.MECHAZILLA.X : CONFIG.SHIP_PAD.X);
        const errX = targetX - v.x;
        const alt = CONFIG.PAD_Y - v.y - v.h/2;

        switch (v.autoMode) {
            case CONSTANTS.AUTO.LAND: this.modeLand(v, dt, alt, errX); break;
            case CONSTANTS.AUTO.HOVER: this.modeHover(v, dt, -100); break;
            case CONSTANTS.AUTO.ORBIT: this.modeOrbit(v, dt, alt); break;
            case CONSTANTS.AUTO.COAST: 
                v.thTgt = 0; v.angVel -= v.angVel * 0.5 * dt; v.currentPhase = "COAST"; break;
        }
    }

    modeLand(v, dt, alt, errX) {
        if (v.type === CONSTANTS.VESSEL.SHIP) { this.landShip(v, dt, alt, errX); }
        else { this.landBooster(v, dt, alt, errX); }
    }

    // --- REFACTORED V9.5: SHIP LANDING LOGIC (Correction for "Weird Directions") ---
    landShip(v, dt, alt, errX) {
        v.gearTgt = alt < 250;
        const mass = v.mass + (v.fuel/100) * v.mass;
        const maxAcc = (v.thrust / mass) - CONFIG.G;
        
        // 1. Horizontal Guidance (Corrected Logic)
        
        let targetVx = 0;
        
        if (alt > 800) {
            // Cruise Phase
            v.currentPhase = "CRUISE";
            // Clamp speed to avoid "weird directions" flying off map
            targetVx = Utils.clamp(errX * 0.1, -40, 40); 
        } else if (alt > 100) {
            // Approach Phase
            v.currentPhase = "APPROACH";
            targetVx = Utils.clamp(errX * 0.5, -15, 15);
        } else {
            // Terminal Phase
            v.currentPhase = "TERMINAL";
            targetVx = Utils.clamp(errX * 1.5, -4, 4);
        }

        const vxErr = targetVx - v.vx;
        
        // PID for Angle
        let targetAng = vxErr * 0.02; // Proportional gain
        
        // Limit angle (Safety)
        const limitAng = (alt < 100) ? 0.15 : 0.6;
        targetAng = Utils.clamp(targetAng, -limitAng, limitAng);
        
        const angErr = targetAng - v.ang;
        v.angVel += (angErr * 4.0 - v.angVel * 2.5) * dt;

        // 2. Vertical Control (Hoverslam)
        const hoverTh = CONFIG.G / (v.thrust / mass);
        // Safety margin calc
        const stopDist = (v.vy * v.vy) / (2 * maxAcc) * 1.1; 
        
        let thCmd = 0;
        if (alt < stopDist + 60 || v.vy > 0) {
             const targetV = (alt < 20) ? 2.0 : Math.sqrt(2 * maxAcc * (alt - 10));
             const vErr = v.vy - (-targetV);
             thCmd = hoverTh + vErr * 0.3;
             
             // Prevent "floating" away if high
             if (alt > 200 && v.vy < -10) thCmd = 0.1; 
        } else {
            // Free fall if far above suicide burn line
            // But if we need horizontal correction, we might need some thrust?
            // V9.5: If error is huge, use engine to correct even if high
            if (Math.abs(errX) > 50) thCmd = 0.3; 
            else thCmd = 0;
        }
        
        v.thTgt = Utils.clamp(thCmd, 0, 1.0);
    }

    // --- REFACTORED V9.5: BOOSTER LANDING LOGIC (Flaps/Grid Fin Aero Steering) ---
    landBooster(v, dt, alt, errX) {
        const mass = v.mass + (v.fuel/100) * v.mass;
        const maxAcc = (v.thrust / mass) - CONFIG.G;
        const hoverTh = CONFIG.G / (v.thrust / mass);
        
        if (alt < 400 && v.vy > 0) v.gearTgt = true; // Legs deploy if needed (though catch usually doesn't need them)

        // Phase 1: Boostback / High Altitude Correction
        if (alt > 2500) {
            v.currentPhase = "BOOSTBACK";
            // If way off target, point engine towards target to boost back
            if (Math.abs(errX) > 100) {
                // Lean towards target
                const targetAng = Utils.clamp(errX * 0.005, -0.6, 0.6);
                const angErr = targetAng - v.ang;
                v.angVel += (angErr * 2.0 - v.angVel * 1.0) * dt;
                
                // Only burn if pointing roughly right
                if (Math.abs(v.ang - targetAng) < 0.2) v.thTgt = 0.8;
                else v.thTgt = 0.1;
            } else {
                v.thTgt = 0;
                // Aerodynamic stability
                v.angVel -= v.ang * 1.0 * dt + v.angVel * 0.5 * dt;
            }
            return;
        }

        // Phase 2: Aero Guidance (Using "Flaps")
        // Falling unpowered. We use body lift/drag to steer.
        if (alt > 600) {
            v.currentPhase = "AERO GUIDANCE";
            
            // „Ç™„Éó„Ç∑„Éß„É≥: „Çπ„É≠„ÉÉ„Éà„É´Ë£úÂä©
            v.thTgt = Utils.clamp(Math.abs(errX) * 0.002, 0, 0.18); 

            let targetAng = -errX * CONFIG.AUTO_LAND.BOOSTER_STEER_GAIN;
            targetAng += v.vx * 0.02;
            
            // 2) ËßíÂ∫¶‰∏äÈôêÁ∑©Âíå
            targetAng = Utils.clamp(targetAng, -0.55, 0.55); 
            
            const angErr = targetAng - v.ang;
            v.angVel += (angErr * 8.0 - v.angVel * 4.0) * dt; 
            return;
        }

        // Phase 3: Landing Burn (Precision Catch)
        const stopDist = (v.vy * v.vy) / (2 * maxAcc * 0.9);
        
        if (alt < stopDist + 120) {
            v.currentPhase = "LANDING BURN";
            
            // V9.8: Convergence focused steering (Anti-Hunting)
            // alt„Åå‰Ωé„ÅÑ„Åª„Å©Ê®™Âà∂Âæ°„ÇíÂº±„ÇÅ„Çã
            const g = Utils.clamp(alt / 180, 0, 1);          // 0..1
            const terminalSteer = 0.018 + 0.012 * g;         // 0.03 ‚Üí 0.018„Å∏ËêΩ„Å°„Çã
            let targetAng = errX * terminalSteer - v.vx * (0.10 + 0.06 * g);

            // ËßíÂ∫¶‰∏äÈôê„ÇÇ alt„ÅßÁµû„ÇãÔºàÂ°î‰ªòËøë„ÅØ„Åª„ÅºÁúü„Å£Áõ¥„ÅêÔºâ
            const maxAng = Utils.lerp(0.06, 0.18, g);        // alt‰Ωé„ÅÑ„Åª„Å©Â∞è„Åï„ÅÑ
            targetAng = Utils.clamp(targetAng, -maxAng, maxAng);

            // ÁõÆÊ®ôËßí„ÇíÊªë„Çâ„Åã„Å´ÔºàÊÄ•ÂèçËª¢„ÅßÂ∑¶Âè≥„Å´ÊåØ„Çå„Å™„ÅÑÔºâ
            v._targetAng = (v._targetAng ?? v.ang);
            v._targetAng = Utils.lerp(v._targetAng, targetAng, 0.20);
            const angErr = v._targetAng - v.ang;

            // ÂèçÂøú„ÇÇÂ∞ë„ÅóÂº±„ÇÅ„Å¶Ê∏õË°∞„ÇíÂ¢ó„ÇÑ„Åô
            v.angVel += (angErr * 10.0 - v.angVel * 7.0) * dt;

            // Vertical Velocity Control
            let targetV = 0;
            // Smoother descent profile
            if (alt > 100) targetV = 35;
            else if (alt > 50) targetV = 15;
            else if (alt > 20) targetV = 5;
            else targetV = 2; 
            
            const vErr = v.vy - (-targetV);
            let thCmd = hoverTh + vErr * 0.5;
            v.thTgt = Utils.clamp(thCmd, 0.0, 1.0);
            
        } else {
            v.currentPhase = "FREEFALL";
            v.thTgt = 0;
            // Prepare orientation for burn
            v.angVel -= v.ang * 3.0 * dt + v.angVel * 1.0 * dt;
        }
    }

    modeHover(v, dt, hTgt) {
        v.currentPhase = "STABILIZED";
        const hErr = hTgt - v.y;
        const vyErr = -v.vy;
        let thOut = 0.3 + (hErr * 0.01) + (vyErr * 0.1);
        v.thTgt = Utils.clamp(thOut, 0, 1);
        v.angVel -= v.ang * 0.1 + v.angVel * 0.1;
    }

    modeOrbit(v, dt, alt) {
        v.currentPhase = "ASCENT";
        const pitchStart = 1000; const pitchEnd = 15000;
        let targetPitch = 0;
        if (alt > pitchStart) {
            const ratio = Math.min(1, (alt - pitchStart) / (pitchEnd - pitchStart));
            targetPitch = (Math.PI / 2) * ratio;
        }
        const angErr = targetPitch - v.ang;
        v.angVel += (angErr * 1.0 - v.angVel * 0.5) * dt;
        
        if (alt < 30000) { v.thTgt = 1.0; }
        else {
            if (v.vx < 800) v.thTgt = 1.0; else v.thTgt = 0;
        }
    }
}

class AudioSystem {
    constructor() {
        this.enabled = true; this.ctx = null; this.ready = false;
    }
    init() {
        if (this.ctx && this.ctx.state === 'running') return;
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            this.ctx.resume().then(() => { this.ready = true; });
            const bufferSize = 2 * this.ctx.sampleRate;
            const noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                output[i] = (0 + (0.02 * white)) / 1.02; output[i] *= 3.5;
            }
            this.noise = this.ctx.createBufferSource();
            this.noise.buffer = noiseBuffer;
            this.noise.loop = true;
            this.gain = this.ctx.createGain();
            this.gain.gain.value = 0;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass'; filter.frequency.value = 150;
            this.noise.connect(filter); filter.connect(this.gain);
            this.gain.connect(this.ctx.destination);
            this.noise.start(0);
        } catch(e) { console.warn("Audio init warning:", e); this.enabled = false; }
    }
    update(v) {
        if (!this.enabled || !this.ready || !this.ctx) return;
        let targetVol = (v && v.active && !v.landed && !v.caught && !v.crashed) ? v.th * 0.6 : 0;
        this.gain.gain.value = Utils.lerp(this.gain.gain.value, targetVol, 0.1);
    }
    toggle() {
        this.enabled = !this.enabled;
        if(this.enabled && this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
        document.getElementById('btn-audio').innerText = this.enabled ? "üîä" : "üîá";
    }
    playTone(freq, duration) {
        if (!this.enabled || !this.ctx) return;
        try {
            const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
            osc.frequency.value = freq; osc.type = 'square'; g.gain.value = 0.05;
            osc.connect(g); g.connect(this.ctx.destination);
            osc.start(); setTimeout(() => osc.stop(), duration * 1000);
        } catch(e){}
    }
    speak(text) {
        if (!('speechSynthesis' in window)) return;
        try {
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'en-US'; u.rate = 1.3; u.pitch = 1.0;
            window.speechSynthesis.speak(u);
        } catch(e){}
    }
}

class UIManager {
    constructor(game) {
        this.game = game; this.els = {};
        ['countdown', 'val-alt', 'val-spd', 'val-fuel', 'vessel-tag', 'auto-tag', 'phase-tag', 'center-msg', 'timer', 'throttle-fill', 'throttle-knob'].forEach(id => {
            this.els[id] = document.getElementById(id);
        });
    }
    update() {
        if (!this.els['timer']) return;
        if (this.game.state === CONSTANTS.STATE.FLIGHT) {
            this.els['timer'].innerText = "T+ " + this.game.time.toFixed(1);
        } else {
            this.els['timer'].innerText = "T- " + Math.abs(this.game.countdown).toFixed(1);
        }

        const v = this.game.vessels ? this.game.vessels[this.game.focus] : null;
        if(!v) return;

        this.els['val-alt'].innerText = Math.max(0, Math.floor(CONFIG.PAD_Y - v.y));
        this.els['val-spd'].innerText = Math.floor(Math.abs(v.vy));
        this.els['val-fuel'].innerText = Math.floor(v.fuel);
        this.els['auto-tag'].style.opacity = v.auto ? 1 : 0;
        this.els['auto-tag'].innerText = "AUTO: " + v.autoMode;

        if(v.auto && v.currentPhase) {
            this.els['phase-tag'].style.opacity = 1;
            this.els['phase-tag'].innerText = "PHASE: " + v.currentPhase;
            if(['TERMINAL','SECURED','CAPTURE','VERTICAL DESCENT','LANDING BURN'].includes(v.currentPhase)) 
                this.els['phase-tag'].style.color = CONSTANTS.COLORS.SUCCESS;
            else if(v.currentPhase === 'CORRECTION' || v.currentPhase === 'BOOSTBACK') 
                this.els['phase-tag'].style.color = CONSTANTS.COLORS.WARN;
            else 
                this.els['phase-tag'].style.color = '#aabbcc';
        } else {
            this.els['phase-tag'].style.opacity = 0;
        }

        document.getElementById('btn-gear').classList.toggle('active', v.gearTgt);
        document.getElementById('btn-auto').classList.toggle('active', v.auto);
        this.els['vessel-tag'].innerText = v.type.toUpperCase();

        if (v.auto) {
            const pct = v.thTgt * 100;
            this.els['throttle-fill'].style.height = pct + '%';
            this.els['throttle-knob'].style.bottom = pct + '%';
        }
    }
    showMessage(txt, color, reason = "") {
        const el = this.els['center-msg'];
        if(!el) return;
        el.innerHTML = txt + (reason ? `<div id="fail-reason">${reason}</div>` : "");
        el.style.color = color;
        el.style.opacity = 1;
        el.style.transform = 'scale(1.1)';
        setTimeout(() => { el.style.opacity=0; el.style.transform='scale(1)'; }, 4000);
    }
    toggleSettings() {
        const p = document.getElementById('settings-panel');
        p.style.display = p.style.display === 'block' ? 'none' : 'block';
    }
    toggleMap() { document.getElementById('minimap-container').classList.toggle('closed'); }
    toggleAutoMenu() {
        if(this.game.state === CONSTANTS.STATE.FLIGHT) document.getElementById('auto-selector').classList.toggle('active');
    }
}

class Renderer {
    constructor(canvas, game) {
        this.cvs = canvas;
        this.ctx = canvas.getContext('2d', { alpha: false });
        this.game = game;
        this.mapCvs = document.getElementById('minimap-canvas');
        if(this.mapCvs) this.mapCtx = this.mapCvs.getContext('2d');
    }
    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.cvs.width = window.innerWidth * dpr;
        this.cvs.height = window.innerHeight * dpr;
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.scale(dpr, dpr);
        if(this.mapCvs) {
            this.mapCvs.width = 140 * dpr; this.mapCvs.height = 140 * dpr;
            this.mapCtx.setTransform(1, 0, 0, 1, 0, 0); this.mapCtx.scale(dpr, dpr);
        }
    }
    draw() {
        if(!this.ctx) return;
        const w = this.cvs.width / (window.devicePixelRatio||1);
        const h = this.cvs.height / (window.devicePixelRatio||1);
        const cam = this.game.cam;
        const alt = Math.max(0, CONFIG.PAD_Y - cam.y);

        let skyColor = '#87CEEB';
        if (alt > 30000) skyColor = '#000000';
        else if (alt > 10000) skyColor = '#191970';
        
        this.ctx.fillStyle = skyColor;
        this.ctx.fillRect(0, 0, w, h);
        
        this.ctx.save();
        this.ctx.translate(w/2, h/2);
        let sx = (Math.random()-0.5) * cam.shake, sy = (Math.random()-0.5) * cam.shake;
        this.game.cam.shake *= 0.9;
        this.ctx.scale(cam.zoom, cam.zoom);
        this.ctx.translate(-cam.x + sx, -cam.y + sy);
        
        this.ctx.fillStyle = '#1a1a1a';
        this.ctx.fillRect(-50000, CONFIG.PAD_Y, 100000, 50000);
        
        this.drawMechazilla();
        this.drawShipPad();

        if (this.game.vessels && this.game.vessels[this.game.focus]) {
            const v = this.game.vessels[this.game.focus];
            if(v && v.auto && v.autoMode === CONSTANTS.AUTO.LAND && !v.landed && v.active) {
                const tx = (v.type === CONSTANTS.VESSEL.BOOSTER ? CONFIG.MECHAZILLA.X : CONFIG.SHIP_PAD.X);
                const errX = Math.abs(v.x - tx);
                const isAligned = errX < 5;
                
                this.ctx.beginPath();
                this.ctx.strokeStyle = isAligned ? 'rgba(0, 255, 100, 0.4)' : 'rgba(255, 200, 0, 0.4)';
                this.ctx.lineWidth = 1;
                this.ctx.setLineDash([5, 5]);
                this.ctx.moveTo(tx, CONFIG.PAD_Y);
                this.ctx.lineTo(tx, v.y);
                this.ctx.stroke();
                this.ctx.setLineDash([]);

                this.ctx.beginPath();
                this.ctx.strokeStyle = isAligned ? '#0f0' : '#fa0';
                this.ctx.lineWidth = 2;
                this.ctx.arc(tx, CONFIG.PAD_Y, 10, 0, Math.PI*2);
                this.ctx.stroke();
            }
        }

        if (this.game.vessels) {
            [CONSTANTS.VESSEL.SHIP, CONSTANTS.VESSEL.BOOSTER].forEach(key => {
                const v = this.game.vessels[key];
                if (v && (v.active || v.landed || v.caught || this.game.state === CONSTANTS.STATE.REPLAY)) this.drawVessel(v);
            });
        }
        
        this.drawParticles();
        this.ctx.restore();
        this.drawMinimap();
    }
    
    drawShipPad() {
        const pad = CONFIG.SHIP_PAD;
        this.ctx.fillStyle = '#666'; this.ctx.fillRect(pad.X - pad.W/2, CONFIG.PAD_Y, pad.W, 10);
        this.ctx.fillStyle = '#444'; 
        this.ctx.fillRect(pad.X - pad.W/2 + 5, CONFIG.PAD_Y, 12, 25);
        this.ctx.fillRect(pad.X + pad.W/2 - 17, CONFIG.PAD_Y, 12, 25);
        this.ctx.fillStyle = '#333'; this.ctx.fillRect(pad.X - 10, CONFIG.PAD_Y, 20, 2);
    }
    
    drawParticles() {
        const particles = this.game.particles.particles;
        if (!particles) return;
        const originalComp = this.ctx.globalCompositeOperation;
        
        for (let p of particles) {
            if (!p.active) continue;
            let size = p.s;
            let alpha = p.life / p.maxLife;

            if (p.c === 'fire') {
                this.ctx.globalCompositeOperation = 'lighter';
                const grad = this.ctx.createRadialGradient(0, 0, 0, 0, 0, size);
                grad.addColorStop(0, `rgba(255, 255, 200, ${alpha})`);
                grad.addColorStop(0.4, `rgba(255, 200, 50, ${alpha * 0.8})`);
                grad.addColorStop(1, `rgba(255, 50, 0, 0)`);
                this.ctx.fillStyle = grad;
                this.ctx.save();
                this.ctx.translate(p.x, p.y);
                const angle = Math.atan2(p.vy, p.vx) + (Math.random()-0.5)*0.2;
                this.ctx.rotate(angle);
                this.ctx.scale(2.5, 0.8);
                this.ctx.beginPath(); this.ctx.arc(0, 0, size, 0, Math.PI * 2); this.ctx.fill();
                this.ctx.restore();
            } else if (p.c === 'smoke') {
                const gray = Math.floor(180 + Math.random() * 50);
                this.ctx.fillStyle = `rgba(${gray}, ${gray}, ${gray}, ${alpha * 0.3})`;
                size = p.s * (1 + (1 - alpha) * 2);
                this.ctx.beginPath(); this.ctx.arc(p.x, p.y, size, 0, Math.PI * 2); this.ctx.fill();
            } else if (p.c === 'shock') {
                this.ctx.save();
                this.ctx.translate(p.x, p.y);
                this.ctx.scale(1.0, 0.3);
                this.ctx.strokeStyle = `rgba(255,255,255,${alpha * 0.8})`;
                this.ctx.lineWidth = 3;
                this.ctx.beginPath(); this.ctx.arc(0, 0, (1-p.life) * 80, 0, Math.PI*2); this.ctx.stroke();
                this.ctx.strokeStyle = `rgba(255,255,255,${alpha * 0.4})`;
                this.ctx.beginPath(); this.ctx.arc(0, 0, (1-p.life) * 60, 0, Math.PI*2); this.ctx.stroke();
                this.ctx.restore();
            }
        }
        this.ctx.globalCompositeOperation = originalComp;
        this.ctx.globalAlpha = 1.0;
    }
    
    drawMinimap() {
        if (!this.mapCtx) return;
        const ctx = this.mapCtx;
        const w = 140; const h = 140;
        ctx.fillStyle = '#001122'; ctx.fillRect(0, 0, w, h);
        ctx.save(); ctx.translate(w/2, h - 20);
        const scale = 0.1; ctx.scale(scale, scale);
        ctx.strokeStyle = '#445566'; ctx.lineWidth = 2 / scale;
        ctx.beginPath(); ctx.moveTo(-600, 0); ctx.lineTo(600, 0); ctx.stroke();
        ctx.fillStyle = '#556677'; ctx.fillRect(CONFIG.MECHAZILLA.X - 15, -240, 30, 240);
        ctx.fillStyle = '#667788'; ctx.fillRect(CONFIG.SHIP_PAD.X - 30, 0, 60, 10);
        if (this.game.vessels) {
            [CONSTANTS.VESSEL.SHIP, CONSTANTS.VESSEL.BOOSTER].forEach(key => {
                const v = this.game.vessels[key];
                if (v && v.active) {
                    ctx.fillStyle = key === CONSTANTS.VESSEL.BOOSTER ? CONSTANTS.COLORS.PRIMARY : '#ffaa00';
                    ctx.beginPath(); ctx.arc(v.x, v.y - CONFIG.PAD_Y, 40, 0, Math.PI*2); ctx.fill();
                }
            });
        }
        ctx.restore();
        ctx.strokeStyle = 'rgba(0,170,255,0.5)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(w/2, h/2, w/2-1, 0, Math.PI*2); ctx.stroke();
    }
    
    drawMechazilla() {
        const tx = CONFIG.MECHAZILLA.X;
        const ty = CONFIG.MECHAZILLA.Y;
        const openVal = this.game.mechazilla?.armOpen ?? 1.0;
        
        const towerDist = 70;
        const towerW = 24;
        
        this.ctx.fillStyle = '#222';
        this.ctx.fillRect(tx - towerDist - towerW, CONFIG.PAD_Y - 320, towerW, 320);
        this.ctx.fillRect(tx + towerDist, CONFIG.PAD_Y - 320, towerW, 320);
        
        this.ctx.strokeStyle = '#444'; this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        for (let y = CONFIG.PAD_Y; y > CONFIG.PAD_Y - 320; y -= 40) {
            this.ctx.moveTo(tx - towerDist - towerW, y); this.ctx.lineTo(tx - towerDist, y - 40);
            this.ctx.moveTo(tx - towerDist, y); this.ctx.lineTo(tx - towerDist - towerW, y - 40);
            this.ctx.moveTo(tx + towerDist, y); this.ctx.lineTo(tx + towerDist + towerW, y - 40);
            this.ctx.moveTo(tx + towerDist + towerW, y); this.ctx.lineTo(tx + towerDist, y - 40);
        }
        this.ctx.stroke();

        const carriageY = ty; 
        const carriageH = 40;
        this.ctx.fillStyle = '#333';
        this.ctx.fillRect(tx - towerDist, carriageY - carriageH/2, 12, carriageH);
        this.ctx.fillRect(tx + towerDist - 12, carriageY - carriageH/2, 12, carriageH);
        
        const booster = this.game.vessels ? this.game.vessels.booster : null;
        const rocketHalfW = booster ? booster.w/2 : 10;
        const minGap = rocketHalfW + 2; 
        const maxGap = 50; 
        const currentGap = Utils.lerp(minGap, maxGap, openVal);

        const armTh = 12; const padW = 14; const padH = 10;

        this.ctx.fillStyle = '#555';
        const leftArmStart = tx - towerDist; const leftArmEnd = tx - currentGap - padW;
        this.ctx.fillRect(leftArmStart, carriageY - armTh/2, leftArmEnd - leftArmStart, armTh);
        this.ctx.fillStyle = '#111';
        this.ctx.fillRect(leftArmEnd, carriageY - padH/2, padW, padH);

        this.ctx.fillStyle = '#555';
        const rightArmStart = tx + towerDist; const rightArmEnd = tx + currentGap + padW;
        this.ctx.fillRect(rightArmEnd, carriageY - armTh/2, rightArmStart - rightArmEnd, armTh);
        this.ctx.fillStyle = '#111';
        this.ctx.fillRect(tx + currentGap, carriageY - padH/2, padW, padH);

        if (openVal < 0.1) {
            this.ctx.fillStyle = '#0f0';
            this.ctx.fillRect(tx - currentGap - 2, carriageY - 2, 4, 4);
            this.ctx.fillRect(tx + currentGap - 2, carriageY - 2, 4, 4);
        }
    }
    
    drawVessel(v) {
        this.ctx.save(); this.ctx.translate(v.x, v.y); this.ctx.rotate(v.ang);
        
        if (v.id === this.game.focus && !this.game.replayMode) {
            this.ctx.shadowBlur = 20; this.ctx.shadowColor = 'rgba(0, 170, 255, 0.3)';
        }

        if (v.type === CONSTANTS.VESSEL.BOOSTER) {
            this.ctx.fillStyle = '#333';
            if (v.gear > 0.1) {
                this.ctx.save(); this.ctx.translate(-v.w/2, -v.h/2 + 10);
                this.ctx.rotate(-0.5 * v.gear); this.ctx.fillRect(-6, -8, 6, 16); this.ctx.restore();
                this.ctx.save(); this.ctx.translate(v.w/2, -v.h/2 + 10);
                this.ctx.rotate(0.5 * v.gear); this.ctx.fillRect(0, -8, 6, 16); this.ctx.restore();
            } else {
                this.ctx.fillRect(-v.w/2 - 2, -v.h/2 + 2, 2, 16);
                this.ctx.fillRect(v.w/2, -v.h/2 + 2, 2, 16);
            }
        }

        const shine = this.ctx.createLinearGradient(-v.w/2, 0, v.w/2, 0);
        shine.addColorStop(0, '#999'); shine.addColorStop(0.2, '#fff');
        shine.addColorStop(0.5, '#eee'); shine.addColorStop(0.8, '#bbb'); shine.addColorStop(1, '#888');
        this.ctx.fillStyle = shine; this.ctx.fillRect(-v.w/2, -v.h/2, v.w, v.h);
        
        this.ctx.fillStyle = 'rgba(0,0,0,0.1)';
        for(let i=1; i<6; i++) { this.ctx.fillRect(-v.w/2, -v.h/2 + i * (v.h/6), v.w, 1); }

        if (v.type === CONSTANTS.VESSEL.BOOSTER) {
            const pinY = -v.h * 0.38;
            this.ctx.fillStyle = '#222';
            this.ctx.fillRect(-v.w/2 - 3, pinY - 2, 3, 4);
            this.ctx.fillRect(v.w/2, pinY - 2, 3, 4);
        }

        const nozzleCount = v.type === CONSTANTS.VESSEL.BOOSTER ? 5 : 3;
        const nozzleW = v.w / nozzleCount;
        const nozzleH = 6;
        const startX = -v.w/2; const startY = v.h/2;
        
        for(let i=0; i<nozzleCount; i++) {
            const nx = startX + i * nozzleW;
            this.ctx.fillStyle = '#222';
            this.ctx.beginPath();
            this.ctx.moveTo(nx, startY); this.ctx.lineTo(nx + nozzleW, startY);
            this.ctx.lineTo(nx + nozzleW - 1, startY + nozzleH); this.ctx.lineTo(nx + 1, startY + nozzleH);
            this.ctx.fill();
            if (v.th > 0.1) {
                this.ctx.fillStyle = `rgba(255, 100, 0, ${v.th})`;
                this.ctx.beginPath();
                this.ctx.moveTo(nx+2, startY+2);
                this.ctx.lineTo(nx + nozzleW-2, startY+2);
                this.ctx.lineTo(nx + nozzleW - 3, startY + nozzleH);
                this.ctx.lineTo(nx + 3, startY + nozzleH);
                this.ctx.fill();
            }
        }

        if (v.type === CONSTANTS.VESSEL.SHIP) {
            this.ctx.fillStyle = shine;
            this.ctx.beginPath();
            this.ctx.moveTo(-v.w/2, -v.h/2); this.ctx.lineTo(v.w/2, -v.h/2);
            this.ctx.bezierCurveTo(v.w/2, -v.h/2 - 25, -v.w/2, -v.h/2 - 25, -v.w/2, -v.h/2);
            this.ctx.fill();
            this.ctx.fillStyle = '#111'; this.ctx.fillRect(-v.w/2, -v.h/2, v.w/2, v.h);
            this.ctx.fillStyle = '#222';
            const aoa = Math.abs(Math.cos(v.ang));
            const flapExt = aoa * 8;
            this.ctx.save(); this.ctx.translate(-v.w/2, v.h/2 - 15);
            this.ctx.rotate(0.2 + flapExt * 0.05); this.ctx.fillRect(-8, 0, 8, 15); this.ctx.restore();
            this.ctx.save(); this.ctx.translate(v.w/2, v.h/2 - 15);
            this.ctx.rotate(-0.2 - flapExt * 0.05); this.ctx.fillRect(0, 0, 8, 15); this.ctx.restore();
            this.ctx.fillRect(-v.w/2 - 6 - flapExt*0.5, -v.h/2 + 5, 6 + flapExt*0.5, 12);
            this.ctx.fillRect(v.w/2, -v.h/2 + 5, 6 + flapExt*0.5, 12);
            this.ctx.fillStyle = '#aaf';
            this.ctx.fillRect(2, -v.h/2 + 15, 2, 2); this.ctx.fillRect(2, -v.h/2 + 20, 2, 2);
            
            if (v.gear > 0.1) {
                this.ctx.fillStyle = '#333';
                const gLen = 15 * v.gear;
                this.ctx.save(); this.ctx.translate(-v.w/2 + 2, v.h/2);
                this.ctx.rotate(0.5); this.ctx.fillRect(0, 0, 3, gLen); this.ctx.restore();
                this.ctx.save(); this.ctx.translate(v.w/2 - 5, v.h/2);
                this.ctx.rotate(-0.5); this.ctx.fillRect(0, 0, 3, gLen); this.ctx.restore();
            }
        } else {
            this.ctx.fillStyle = '#111'; this.ctx.fillRect(-v.w/2, -v.h/2, v.w, 4);
        }
        this.ctx.restore();
    }
}

class InputManager {
    constructor(game) {
        this.game = game;
        this.x = 0; this.th = 0;
        this.isDrag = false;
        this.dragStart = { x: 0, y: 0 };
        this.camStart = { x: 0, y: 0 };
        this.pinchDist = 0;
        this.pointers = new Map();
        this.setup();
    }
    setup() {
        document.addEventListener('keydown', (e) => {
            if(e.key === 'ArrowLeft') this.x = -1;
            if(e.key === 'ArrowRight') this.x = 1;
            if(e.key === ' ') this.th = 1;
        });
        document.addEventListener('keyup', (e) => {
            if(e.key === 'ArrowLeft' || e.key === 'ArrowRight') this.x = 0;
            if(e.key === ' ') this.th = 0;
        });
        const joy = document.getElementById('joystick-zone');
        const stick = document.getElementById('stick-handle');
        let joyId = null;
        const handleJoy = (ex, ey, rect) => {
            const maxR = rect.width/2;
            let dx = ex - (rect.left + maxR);
            let dy = ey - (rect.top + maxR);
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > maxR) { dx = (dx/dist)*maxR; dy = (dy/dist)*maxR; }
            stick.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
            this.x = dx / maxR;
        };
        joy.onpointerdown = e => { joyId = e.pointerId; e.stopPropagation(); handleJoy(e.clientX, e.clientY, joy.getBoundingClientRect()); };
        joy.onpointermove = e => { if(e.pointerId === joyId) { e.stopPropagation(); handleJoy(e.clientX, e.clientY, joy.getBoundingClientRect()); } };
        joy.onpointerup = e => { if(e.pointerId === joyId) { joyId = null; this.x = 0; stick.style.transform = `translate(-50%, -50%)`; } };

        const thZone = document.getElementById('throttle-zone');
        let thId = null;
        const handleTh = (ey, rect) => {
            let val = Utils.clamp(1.0 - (ey - rect.top) / rect.height, 0, 1);
            this.th = val; this.updateThUI(val);
            const v = this.game.vessels ? this.game.vessels[this.game.focus] : null;
            if(v && v.auto && Math.abs(v.thTgt - val) > 0.1) v.auto = false;
        };
        thZone.onpointerdown = e => { thId = e.pointerId; e.stopPropagation(); handleTh(e.clientY, thZone.getBoundingClientRect()); };
        thZone.onpointermove = e => { if(e.pointerId === thId) { e.stopPropagation(); handleTh(e.clientY, thZone.getBoundingClientRect()); } };
        thZone.onpointerup = e => { thId = null; };

        const cvs = document.getElementById('game-canvas');
        cvs.addEventListener('wheel', (e) => this.handleWheel(e), { passive: false });
        cvs.addEventListener('pointerdown', (e) => this.handlePointerDown(e));
        cvs.addEventListener('pointermove', (e) => this.handlePointerMove(e));
        cvs.addEventListener('pointerup', (e) => this.handlePointerUp(e));
        cvs.addEventListener('pointercancel', (e) => this.handlePointerUp(e));
        cvs.addEventListener('pointerout', (e) => this.handlePointerUp(e));
    }
    updateThUI(val) {
        const fill = document.getElementById('throttle-fill');
        const knob = document.getElementById('throttle-knob');
        if (fill && knob) { fill.style.height = (val*100)+'%'; knob.style.bottom = (val*100)+'%'; }
    }
    handleWheel(e) {
        e.preventDefault();
        const zoomSpeed = 0.001;
        this.game.cam.zoom = Utils.clamp(this.game.cam.zoom - e.deltaY * zoomSpeed, CONFIG.CAM.ZOOM_MIN, CONFIG.CAM.ZOOM_MAX);
    }
    handlePointerDown(e) {
        this.pointers.set(e.pointerId, e);
        if (this.pointers.size === 1) {
            const rect = e.target.getBoundingClientRect();
            const wx = (e.clientX - window.innerWidth/2) / this.game.cam.zoom + this.game.cam.x;
            const wy = (e.clientY - window.innerHeight/2) / this.game.cam.zoom + this.game.cam.y;
            let clicked = null;
            if (this.game.vessels) {
                [CONSTANTS.VESSEL.BOOSTER, CONSTANTS.VESSEL.SHIP].forEach(key => {
                    const v = this.game.vessels[key];
                    if(v && Utils.dist(wx, wy, v.x, v.y) < 30) clicked = key;
                });
            }
            if(clicked) {
                this.game.focus = clicked;
                if(this.game.vessels && this.game.vessels[clicked]) {
                    this.game.cam.target = this.game.vessels[clicked];
                    this.game.cam.auto = true;
                    this.game.ui.showMessage("TRACKING: " + clicked.toUpperCase(), CONSTANTS.COLORS.SUCCESS);
                }
            } else {
                this.game.cam.auto = false;
                this.isDrag = true;
                this.dragStart = { x: e.clientX, y: e.clientY };
                this.camStart = { x: this.game.cam.x, y: this.game.cam.y };
            }
        } else if (this.pointers.size === 2) {
            this.isDrag = false;
            const pts = Array.from(this.pointers.values());
            this.pinchDist = Utils.dist(pts[0].clientX, pts[0].clientY, pts[1].clientX, pts[1].clientY);
        }
    }
    handlePointerMove(e) {
        this.pointers.set(e.pointerId, e);
        if (this.pointers.size === 1 && this.isDrag) {
            const dx = (e.clientX - this.dragStart.x) / this.game.cam.zoom;
            const dy = (e.clientY - this.dragStart.y) / this.game.cam.zoom;
            this.game.cam.x = this.camStart.x - dx;
            this.game.cam.y = this.camStart.y - dy;
        } else if (this.pointers.size === 2) {
            const pts = Array.from(this.pointers.values());
            const newDist = Utils.dist(pts[0].clientX, pts[0].clientY, pts[1].clientX, pts[1].clientY);
            const scale = newDist / this.pinchDist;
            this.game.cam.zoom = Utils.clamp(this.game.cam.zoom * scale, CONFIG.CAM.ZOOM_MIN, CONFIG.CAM.ZOOM_MAX);
            this.pinchDist = newDist;
        }
    }
    handlePointerUp(e) {
        this.pointers.delete(e.pointerId);
        if (this.pointers.size < 2) this.pinchDist = 0;
        if (this.pointers.size === 0) this.isDrag = false;
    }
}

class RocketGame {
    constructor() {
        this.settings = new SettingsManager();
        this.particles = new ParticleSystem();
        this.physics = new PhysicsEngine(this);
        this.autopilot = new Autopilot();
        this.audio = new AudioSystem();
        this.ui = new UIManager(this);
        this.input = new InputManager(this);
        this.ai = new GeminiBridge();
        
        this.cam = { x: 0, y: -100, zoom: 0.8, shake: 0, auto: true };
        this.vessels = {};
        this.focus = CONSTANTS.VESSEL.BOOSTER;
        this.state = CONSTANTS.STATE.MENU;
        this.time = 0;
        this.countdown = 10;
        this.mechazilla = { armOpen: 1.0 };
        this.weather = { wind: 0, isDay: true };
        this.replayMode = false;
        this.replayData = [];
        this.replayIndex = 0;
        this.sas = true;
        this.lastTime = 0;
        
        // Auto Ascent Sequence Control
        this.ascent = { active: false, t: 0 };
    }
    
    init() {
        this.settings.applyToDOM();
        this.canvas = document.getElementById('game-canvas');
        this.renderer = new Renderer(this.canvas, this);
        window.addEventListener('resize', () => this.renderer.resize());
        this.renderer.resize();
        this.fetchWeather();
        this.setupVessels();
        requestAnimationFrame(t => this.loop(t));
        setInterval(() => this.updateClock(), 1000);
        this.attachEvents();
    }
    
    attachEvents() {
        const bind = (id, fn) => { const el = document.getElementById(id); if(el) el.addEventListener('click', fn); };
        bind('btn-settings', () => this.ui.toggleSettings());
        bind('btn-map', () => this.ui.toggleMap());
        bind('btn-audio', () => this.audio.toggle());
        bind('opt-traj', (e) => this.settings.toggle('trajectory', e.currentTarget));
        bind('opt-mass', (e) => this.settings.toggle('massShift', e.currentTarget));
        bind('opt-replay', (e) => this.settings.toggle('replay', e.currentTarget));
        bind('vessel-tag', () => this.resetCam());
        bind('mode-land', () => this.setMode(CONSTANTS.AUTO.LAND));
        bind('mode-hover', () => this.setMode(CONSTANTS.AUTO.HOVER));
        bind('mode-off', () => this.setMode(CONSTANTS.AUTO.OFF));
        bind('btn-cam', () => this.switchVessel());
        bind('btn-gear', () => this.toggleGear());
        bind('btn-sas', () => this.toggleSAS());
        bind('btn-auto', () => this.ui.toggleAutoMenu());
        bind('btn-sep', () => this.separation());
        bind('btn-rst', () => this.softReset());
        bind('btn-bft', () => this.performBFT());
        
        bind('btn-ai-status', () => {
            const v = this.vessels ? this.vessels[this.focus] : null;
            if (!v) return;
            const status = `Alt: ${Math.round(CONFIG.PAD_Y - v.y)}m, Speed: ${Math.round(Math.abs(v.vy))}m/s, Fuel: ${Math.round(v.fuel)}%, Phase: ${v.currentPhase || "CRUISE"}`;
            const panel = document.getElementById('report-panel');
            if(panel) {
                panel.style.display = 'flex';
                document.getElementById('report-content').innerHTML = `
                    <strong>ALTITUDE:</strong> ${Math.round(CONFIG.PAD_Y - v.y)} m<br>
                    <strong>VELOCITY:</strong> ${Math.round(v.vy)} m/s<br>
                    <strong>FUEL:</strong> ${Math.round(v.fuel)} %<br>
                    <strong>PHASE:</strong> ${v.currentPhase || "MANUAL"}<br>
                    <strong>MODE:</strong> ${v.auto ? v.autoMode : "MANUAL"}
                `;
            }
            this.ai.generateCommentary(status, true);
        });
    }

    setupVessels() {
        const b = {
            id: CONSTANTS.VESSEL.BOOSTER, type: CONSTANTS.VESSEL.BOOSTER,
            x: 0, y: CONFIG.PAD_Y - CONFIG.BOOSTER.H/2 - 5,
            vx: 0, vy: 0, ang: 0, angVel: 0,
            fuel: 100, fuelMax: CONFIG.BOOSTER.FUEL,
            thrust: CONFIG.BOOSTER.THRUST, mass: CONFIG.BOOSTER.MASS,
            th: 0, thTgt: 0,
            gear: 1, gearTgt: true, gearOffset: 12,
            auto: false, autoMode: CONSTANTS.AUTO.OFF,
            active: true, landed: false, crashed: false, caught: false, hasLiftedOff: false,
            w: CONFIG.BOOSTER.W, h: CONFIG.BOOSTER.H, color: '#eef',
            captured: false, // New Property for Hard Lock
            trail: [], history: [], currentPhase: 'PRE-FLIGHT'
        };
        const s = {
            id: CONSTANTS.VESSEL.SHIP, type: CONSTANTS.VESSEL.SHIP,
            x: 0, y: b.y - CONFIG.BOOSTER.H/2 - CONFIG.SHIP.H/2,
            vx: 0, vy: 0, ang: 0, angVel: 0,
            fuel: 100, fuelMax: CONFIG.SHIP.FUEL,
            thrust: CONFIG.SHIP.THRUST, mass: CONFIG.SHIP.MASS,
            th: 0, thTgt: 0,
            gear: 0, gearTgt: false, gearOffset: 15,
            auto: false, autoMode: CONSTANTS.AUTO.OFF,
            active: true, landed: false, crashed: false, sep: false, hasLiftedOff: false,
            w: CONFIG.SHIP.W, h: CONFIG.SHIP.H, color: '#ddd',
            trail: [], history: [], currentPhase: 'PRE-FLIGHT'
        };
        this.vessels = { [CONSTANTS.VESSEL.BOOSTER]: b, [CONSTANTS.VESSEL.SHIP]: s };
        this.focus = CONSTANTS.VESSEL.BOOSTER;
        if(this.cam) this.cam.target = b;
    }

    performBFT() {
        if (!this.vessels) return;
        const v = this.vessels[this.focus];
        if(!v || !v.active) return;
        this.ui.showMessage("BURST FIRE TEST", CONSTANTS.COLORS.WARN);
        this.audio.playTone(200, 0.5);
        this.cam.shake = 10;
        for(let i=0; i<40; i++) {
            this.particles.add(
                v.x + Utils.rand(-10, 10), v.y + Utils.rand(-20, 20),
                Utils.rand(-100, 100), Utils.rand(-100, 100),
                Utils.rand(4, 8), 'smoke', 0.6
            );
        }
        v.angVel += (Math.random() - 0.5) * 2.5;
    }

    handleLaunch() {
        if (this.state !== CONSTANTS.STATE.MENU) return;
        try { this.audio.init(); } catch(e) { console.warn(e); }
        const sc = document.getElementById('start-screen');
        if(sc) { sc.style.opacity = 0; setTimeout(() => { sc.style.display = 'none'; }, 500); }
        this.setupVessels();
        this.state = CONSTANTS.STATE.COUNTDOWN;
        this.countdown = 10; this.time = 0;
        const cdEl = document.getElementById('countdown');
        if(cdEl) { cdEl.style.opacity = 1; cdEl.innerText = "10"; }
        this.audio.speak("Ten");
    }

    liftoff() {
        try {
            this.state = CONSTANTS.STATE.FLIGHT;
            const cdEl = document.getElementById('countdown');
            if(cdEl) cdEl.style.opacity = 0;
            const autoBtn = document.getElementById('btn-auto');
            if(autoBtn) autoBtn.classList.remove('disabled');

            if (!this.vessels || !this.vessels.booster) return;
            const b = this.vessels.booster;
            const s = this.vessels.ship;
            
            b.thTgt = 1.0; b.gearTgt = false;
            b.y -= 18; b.vy = -12;
            b.hasLiftedOff = false;
            b.currentPhase = "LIFTOFF";
            if(s) s.currentPhase = "LIFTOFF";

            this.input.th = 1.0; this.input.updateThUI(1.0);
            
            if (!this.ascent) this.ascent = { active: false, t: 0 };
            this.ascent.active = false; this.ascent.t = 0;
            
            for(let i=0; i<150; i++) {
                this.particles.add(b.x, b.y + 50, Utils.rand(-25, 25), Utils.rand(10, 40), Utils.rand(6,12), 'fire', 1.0);
            }
            this.ai.generateCommentary("LIFTOFF! Manual control engaged.");
        } catch(e) {
            console.error("Liftoff Error:", e);
        }
    }

    loop(now) {
        requestAnimationFrame(t => this.loop(t));
        let dt = (now - this.lastTime) / 1000;
        this.lastTime = now;
        if(dt > 0.1) dt = 0.1;
        if (this.state === CONSTANTS.STATE.REPLAY) { this.updateReplay(); } else { this.update(dt); }
        this.renderer.draw();
    }

    update(dt) {
        if (this.state === CONSTANTS.STATE.FLIGHT) this.time += dt;

        if (this.state === CONSTANTS.STATE.COUNTDOWN) {
            const prev = Math.ceil(this.countdown);
            this.countdown -= dt;
            const c = Math.ceil(this.countdown);
            if (c !== prev) {
                const el = document.getElementById('countdown');
                if (c >= 0) {
                    if(el) {
                        el.innerText = c; el.style.opacity = 1; el.style.transform = 'scale(1.2)';
                        setTimeout(() => el.style.transform = 'scale(1)', 100);
                    }
                    this.audio.playTone(800, 0.1);
                    if(c > 0) this.audio.speak(c.toString());
                }
                if (c === 0) {
                    if(el) el.innerText = "LIFTOFF";
                    this.audio.playTone(1200, 0.5); this.audio.speak("Liftoff");
                    this.liftoff();
                }
            }
        }

        // Auto Ascent Sequence
        if (this.state === CONSTANTS.STATE.FLIGHT && this.ascent && this.ascent.active) {
            this.ascent.t += dt;
            if (this.vessels && this.vessels.booster && this.vessels.ship) {
                const b = this.vessels.booster; const s = this.vessels.ship;
                if (this.ascent.t < 2.2) { b.thTgt = 1.0; b.currentPhase = "ASCENT"; }
                else if (this.ascent.t < 3.8) { b.thTgt = 0.18; b.currentPhase = "THROTTLE DOWN"; }
                else {
                    if (!s.sep) this.separation();
                    this.ascent.active = false;
                }
            }
        }

        // Low Fuel Return
        if (this.vessels && this.vessels.ship) {
            const s = this.vessels.ship;
            if (s.sep && !s.landed && s.active && s.fuel < 20 && s.fuel > 0 && s.autoMode !== CONSTANTS.AUTO.LAND) {
                s.auto = true; s.autoMode = CONSTANTS.AUTO.LAND;
                this.ui.showMessage("LOW FUEL - AUTO R.T.L.", CONSTANTS.COLORS.WARN);
                this.ai.generateCommentary("Ship fuel low. Initiating automated Return To Launch.");
            }
        }

        if (this.state === CONSTANTS.STATE.FLIGHT) {
            if (this.vessels && this.vessels.booster) {
                const b = this.vessels.booster;
                this.physics.update(b, dt);
                if (this.vessels.ship) {
                    const s = this.vessels.ship;
                    if (s.sep) { this.physics.update(s, dt); }
                    else {
                        s.x = b.x + Math.sin(b.ang) * (b.h/2 + s.h/2);
                        s.y = b.y - Math.cos(b.ang) * (b.h/2 + s.h/2);
                        s.vx = b.vx; s.vy = b.vy; s.ang = b.ang; s.angVel = b.angVel; s.active = true;
                    }
                }
            }
        }

        const t = this.cam.target;
        if (t && this.cam.auto && !this.input.isDrag) {
            const tx = t.x + t.vx * 0.5; const ty = t.y + t.vy * 0.5;
            this.cam.x = Utils.lerp(this.cam.x, tx, 0.05);
            this.cam.y = Utils.lerp(this.cam.y, ty, 0.05);
            const spd = Math.sqrt(t.vx**2 + t.vy**2);
            const targetZoom = Utils.clamp(1.5 - spd * 0.002, 0.5, 1.5);
            this.cam.zoom = Utils.lerp(this.cam.zoom, targetZoom, 0.01);
        }

        if (this.vessels && this.vessels.booster) {
            const b = this.vessels.booster;
            if (b.caught) {
                this.mechazilla.armOpen = Utils.lerp(this.mechazilla.armOpen, 0.0, 0.05);
            } else {
                const distX = Math.abs(b.x - CONFIG.MECHAZILLA.X);
                const pinY = b.y - (b.h * 0.38);
                const distPin = pinY - CONFIG.MECHAZILLA.Y;
                const preparing = distX < 180 && distPin < 220 && distPin > -260;
                const inCatchZone = distX < 55 && distPin > -28 && distPin < 45;
                
                if (inCatchZone) this.mechazilla.armOpen = Utils.lerp(this.mechazilla.armOpen, 0.0, 0.14);
                else if (preparing) this.mechazilla.armOpen = Utils.lerp(this.mechazilla.armOpen, 1.0, 0.06);
                else this.mechazilla.armOpen = Utils.lerp(this.mechazilla.armOpen, 0.25, 0.03);
            }
        }

        this.particles.update(dt);
        this.ui.update();
        if (this.vessels && this.focus && this.vessels[this.focus]) {
            this.audio.update(this.vessels[this.focus]);
        }
    }

    switchVessel() {
        this.focus = this.focus === CONSTANTS.VESSEL.BOOSTER ? CONSTANTS.VESSEL.SHIP : CONSTANTS.VESSEL.BOOSTER;
        if(this.vessels && this.vessels[this.focus]) {
            this.cam.target = this.vessels[this.focus];
            this.ui.showMessage("TRACKING: " + this.focus.toUpperCase(), CONSTANTS.COLORS.PRIMARY);
        }
    }
    toggleGear() {
        if(this.vessels && this.vessels[this.focus]) {
            const v = this.vessels[this.focus]; v.gearTgt = !v.gearTgt;
        }
    }
    toggleSAS() {
        this.sas = !this.sas;
        document.getElementById('btn-sas').classList.toggle('active', this.sas);
    }
    setMode(mode) {
        if(this.vessels && this.vessels[this.focus]) {
            const v = this.vessels[this.focus]; v.autoMode = mode; v.auto = (mode !== CONSTANTS.AUTO.OFF);
            const sel = document.getElementById('auto-selector'); if(sel) sel.classList.remove('active');
        }
    }
    resetCam() {
        if(this.vessels && this.vessels[this.focus]) {
            this.cam.target = this.vessels[this.focus]; this.cam.auto = true;
        }
    }
    softReset() {
        this.state = CONSTANTS.STATE.MENU; this.setupVessels(); this.particles.clear();
        this.input.th = 0; this.input.updateThUI(0);
        const sc = document.getElementById('start-screen'); if(sc) { sc.style.display = 'flex'; sc.style.opacity = 1; }
        const btnAuto = document.getElementById('btn-auto'); if(btnAuto) btnAuto.classList.add('disabled');
        const cdEl = document.getElementById('countdown'); if(cdEl) cdEl.style.opacity = 0;
        this.ui.showMessage("SYSTEM READY", CONSTANTS.COLORS.PRIMARY);
    }
    separation() {
        if(this.state !== CONSTANTS.STATE.FLIGHT) return;
        if (!this.vessels || !this.vessels.ship || !this.vessels.booster) return;
        const s = this.vessels.ship; const b = this.vessels.booster;
        s.sep = true; s.vy -= 12; s.auto = true; s.autoMode = CONSTANTS.AUTO.ORBIT;
        this.ui.showMessage("SEPARATION - SHIP TO ORBIT", CONSTANTS.COLORS.SUCCESS);
        this.audio.speak("Separation confirmed. Ship ascending to orbit.");
        this.ai.generateCommentary("Separation confirmed. Ship initiating orbital insertion.");
        b.auto = true; b.autoMode = CONSTANTS.AUTO.LAND;
        this.focus = CONSTANTS.VESSEL.SHIP; this.cam.target = s;
        this.particles.add(s.x, s.y + 40, 0, 0, 1, 'shock', 1.0);
    }
    recordHistory(v) {
        v.history.push({ x: v.x, y: v.y, ang: v.ang, th: v.th, gear: v.gear });
        if(v.history.length > 300) v.history.shift();
    }
    handleLanding(v, type) {
        const vOk = Math.abs(v.vy) < 22;
        const aOk = Math.abs(v.ang) < 0.3;
        const gOk = v.gear > 0.8 || type === 'MECHAZILLA CATCH';

        if (vOk && aOk && gOk) {
            if (type === 'MECHAZILLA CATCH') {
                v.caught = true;
                this.ui.showMessage("CATCH CONFIRMED", CONSTANTS.COLORS.SUCCESS);
                this.audio.speak("Catch Confirmed");
                this.ai.generateCommentary("Tower catch successful! Systems nominal.");
            } else {
                v.landed = true;
                v.y = CONFIG.PAD_Y - v.h/2 - (v.gear > 0.5 ? v.gearOffset : 0);
                this.ui.showMessage("TOUCHDOWN", CONSTANTS.COLORS.SUCCESS);
                this.audio.speak("Touchdown");
                this.ai.generateCommentary("Touchdown confirmed. Welcome back.");
                for(let i=0; i<30; i++) {
                    this.particles.add(v.x + Utils.rand(-20,20), v.y + v.h/2, Utils.rand(-30,30), -5, Utils.rand(4,8), 'smoke', 1.5);
                }
            }
            v.th = 0; v.vx = 0; v.vy = 0; v.angVel = 0; v.ang = 0; v.auto = false; v.currentPhase = "SECURED";
            if(this.settings.config.replay) { setTimeout(() => this.startReplay(v), 2500); }
        } else {
            v.crashed = true; v.active = false; v.th = 0;
            let reason = "";
            if (!vOk) reason = `SPEED: ${Math.abs(v.vy).toFixed(1)} m/s (LIMIT: 22)`;
            else if (!aOk) reason = `ANGLE: ${(Math.abs(v.ang)*57.3).toFixed(1)}¬∞ (LIMIT: 17¬∞)`;
            else if (!gOk) reason = "GEAR NOT DEPLOYED";
            
            this.ui.showMessage("CRITICAL FAILURE", CONSTANTS.COLORS.WARN, reason);
            this.cam.shake = 50;
            this.particles.add(v.x, v.y, 0, 0, 1, 'shock', 1.0);
            for(let i=0; i<80; i++) this.particles.add(v.x, v.y, Utils.rand(-60,60), Utils.rand(-80,-10), Utils.rand(4,10), 'fire', 0.8);
            this.ai.generateCommentary("Vehicle lost. Investigation protocol initiated.");
            if(this.settings.config.replay) { setTimeout(() => this.startReplay(v), 2000); }
        }
    }
    startReplay(v) {
        if(v.history.length < 10) return;
        this.state = CONSTANTS.STATE.REPLAY; this.replayMode = true;
        this.replayData = [...v.history]; this.replayIndex = 0;
        const ri = document.getElementById('replay-indicator'); if(ri) ri.style.display = 'block';
        this.cam.target = null;
    }
    updateReplay() {
        if (this.replayIndex >= this.replayData.length) {
            this.state = CONSTANTS.STATE.MENU; this.replayMode = false;
            const ri = document.getElementById('replay-indicator'); if(ri) ri.style.display = 'none';
            const sc = document.getElementById('start-screen'); if(sc) { sc.style.display = 'flex'; sc.style.opacity = 1; }
            return;
        }
        const frame = this.replayData[this.replayIndex++];
        const v = this.vessels[this.focus];
        v.x = frame.x; v.y = frame.y; v.ang = frame.ang; v.th = frame.th; v.gear = frame.gear;
        this.cam.x = v.x; this.cam.y = v.y; this.cam.zoom = 1.5;
    }
    updateClock() {
        const el = document.getElementById('real-time');
        if(el) el.innerText = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    }
    async fetchWeather() {
        try {
            const r = await fetch('https://api.open-meteo.com/v1/forecast?latitude=35.6895&longitude=139.6917&current_weather=true');
            if(!r.ok) throw new Error('API Fail');
            const d = await r.json(); const w = d.current_weather;
            this.weather.wind = w.windspeed; this.weather.isDay = w.is_day === 1;
            const wi = document.getElementById('weather-info');
            if(wi) wi.innerText = `${w.temperature}¬∞C / W:${w.windspeed}`;
        } catch(e) { const hours = new Date().getHours(); this.weather.isDay = (hours >= 6 && hours <= 18); }
    }
}

if (document.readyState === "complete" || document.readyState === "interactive") { setTimeout(initGame, 1); }
else { document.addEventListener("DOMContentLoaded", initGame); }

function initGame() {
    console.log("Initializing v17.0 V10.0 ULTIMATE - Integrated Edition...");
    if(window.gameInstance) return;
    window.game = new RocketGame();
    window.gameInstance = true;
    window.game.init();
    
    const btn = document.getElementById('btn-launch');
    if(btn) {
        btn.onclick = (e) => { e.preventDefault(); e.stopPropagation(); window.game.handleLaunch(); };
        btn.ontouchstart = (e) => { e.preventDefault(); e.stopPropagation(); window.game.handleLaunch(); };
    }
    window.forceStart = () => window.game.handleLaunch();
    document.getElementById('start-screen').onclick = (e) => {
        if(e.target.id === 'start-screen') { window.game.handleLaunch(); }
    }
    console.log("System Ready");
}
</script>
</body>
</html>
